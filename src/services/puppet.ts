import { ChildProcess } from 'child_process';
import { WebSocketServiceType } from '../types/websocket';
import { ProcessManager } from './process-manager';
import { ProcessMessage } from '../types/process';
import { Socket } from 'socket.io';
import { PuppetEvent, PuppetLoginStatus } from '../types/puppet-event';

export class Puppet {
  socket: Socket | null;
  serviceId: WebSocketServiceType;
  clientId: string;
  process: ChildProcess;
  state: PuppetLoginStatus = PuppetLoginStatus.pending;

  constructor(serviceId: WebSocketServiceType, clientId: string, socket: Socket, process: ChildProcess){
    this.socket = socket;
    this.serviceId = serviceId;
    this.process = process;
    this.clientId = clientId;
  }

  init(){
    this.initPuppetSocket();
    this.initPuppetProcess();
  }

  private initPuppetSocket(){
    // Verify code
    this.socket?.on(PuppetEvent.clientSubmitVerifyCode, this.onVerifyCode);
    
    this.socket?.on('disconnect', () => {
      console.log('Socket.IO client disconnected');
      if(this.state == PuppetLoginStatus.login){
        // Logged in, just close the connection
        this.closeConnection();
      } else {
        // Destroy the client
        PuppetService.getInstance().destoryPuppet(this.clientId);
      }
    });
  }
  // Init the worker process
  private initPuppetProcess(){

    // Handle the message sent by worker process
    this.process.on('message', (message: ProcessMessage)=>{

      // Forward to client if has the collection
      if(message.type == PuppetEvent.puppetDispatchAuthToken){
        // The authorization token (qrCode) generated by wechaty
        // Return to the client
        this.socket?.emit(PuppetEvent.puppetDispatchAuthToken, message.data);
      } else if(message.type == PuppetEvent.puppetRequestVerifyCode){
        // Notify the client to input verification code
        this.socket?.emit(PuppetEvent.puppetRequestVerifyCode);
      } else if(message.type == PuppetEvent.puppetVerifyResult){
        // Report verify result
        console.log('verifyCodeResult:', message.data);
        // Tell the login client
        this.socket?.emit(PuppetEvent.puppetVerifyResult, message.data);
      } else if(message.type == PuppetEvent.puppetLoginStatus){
        // Report verify result
        console.log('login status:', message.data);
        // Tell the login client
        this.state = message.data;
        this.socket?.emit(PuppetEvent.puppetLoginStatus, message.data);
        if(message.data == PuppetLoginStatus.login){
          // Verify code passed, disable the timeout, so the puppet will serve for the customer
          PuppetService.getInstance().disableTimeout(this.clientId);
        } else if(message.data == PuppetLoginStatus.logout){
          // Logout
          PuppetService.getInstance().destoryPuppet(this.clientId);
        }
      } else if(message.type == PuppetEvent.puppetError){
        // Tell the login client
        this.socket?.emit(PuppetEvent.puppetError, message.data);
        PuppetService.getInstance().destoryPuppet(this.clientId);
      }
    });
  }

  // Client submit verification code for login
  private onVerifyCode = (verificationCode: string) => {

    this.process.send({ type: PuppetEvent.clientSubmitVerifyCode, data: verificationCode });
  }

  updateSocket(newSocket: Socket): void {
    this.socket = newSocket;
    // Socket updated, send the login status
    this.socket?.emit(PuppetEvent.puppetLoginStatus, this.state);
  }
  
  closeConnection() {
    if(this.socket){
      this.socket.disconnect();
      this.socket = null;
    }
  }
}


export class PuppetService {

  static instance: PuppetService;

  processManager = new ProcessManager();
  private serviceId;
  private puppets: Map<string, Puppet> = new Map();
  private timeouts: Map<string, NodeJS.Timeout> = new Map();

  static getInstance() {
    if (!PuppetService.instance) {
      PuppetService.instance = new PuppetService(WebSocketServiceType.ZionSupport);
    }
    return PuppetService.instance;
  }
  
  private constructor(serviceId: WebSocketServiceType) {
    this.serviceId = serviceId;
  }

  createPuppet(serviceId: WebSocketServiceType, clientId: string, socket: Socket) {
    // Check if puppet with clientId already exists
    const existingPuppet = this.puppets.get(clientId);

    if (existingPuppet) {
      // Update the socket of the existing puppet
      existingPuppet.updateSocket(socket);
    } else {
      // Start worker process for wechaty puppet
      const puppetWorker = this.processManager.startProcess(serviceId, clientId,
        process.env.NODE_ENV == 'production'?
        './puppet-worker.js' : './puppet-worker.ts');

      const puppet = new Puppet(serviceId, clientId, socket, puppetWorker);
      // Init the worker
      puppet.init();
      this.puppets.set(clientId, puppet);

      // Terminate the child process in 3 minutes by default
      const timeout = setTimeout(() => {
        this.destoryPuppet(clientId);
      }, 3 * 60 * 1000);
      this.timeouts.set(clientId, timeout);
    }
  }

  destoryPuppet(clientId: string){
    const existingPuppet = this.puppets.get(clientId);
    if (existingPuppet) {
      existingPuppet.closeConnection();
    }
    this.disableTimeout(clientId);
    this.processManager.terminateProcess(clientId);
    this.puppets.delete(clientId);
  }

  // Disable the timeout for child process
  disableTimeout(clientId: string): void {
    const timeout = this.timeouts.get(clientId);
    if (timeout) {
      clearTimeout(timeout);
      this.timeouts.delete(clientId);
    }
  }
}