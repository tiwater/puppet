import { ChildProcess } from 'child_process';
import { WebSocketServiceType } from '../types/websocket';
import { ProcessManager } from './process-manager';
import { ProcessMessage } from '../types/process';
import { Socket } from 'socket.io';
import { ControllerEvent, PuppetEvent, PuppetLoginStatus } from '../types/puppet-event';

class Token {
  value: string;
  isOccupied: boolean;

  constructor(value: string) {
    this.value = value;
    this.isOccupied = false;
  }
}

class TokenManager {
  private tokens: Token[];

  constructor(initialTokens: string[]) {
    this.tokens = initialTokens.map(tokenValue => new Token(tokenValue));
  }

  requestToken(): string | null {
    const availableToken = this.tokens.find(token => !token.isOccupied);

    if (!availableToken) {
      return null;
    }

    availableToken.isOccupied = true;
    return availableToken.value;
  }

  releaseToken(tokenValue: string): void {
    const token = this.tokens.find(token => token.value === tokenValue);

    if (token) {
      token.isOccupied = false;
    } else {
      throw new Error(`Token ${tokenValue} not found.`);
    }
  }
}

export class Puppet {
  socket: Socket | null;
  serviceId: WebSocketServiceType;
  clientId: string;
  process: ChildProcess;
  token: string;
  state: PuppetLoginStatus = PuppetLoginStatus.pending;

  constructor(serviceId: WebSocketServiceType, clientId: string, socket: Socket, 
    token: string, process: ChildProcess){
    this.socket = socket;
    this.serviceId = serviceId;
    this.process = process;
    this.clientId = clientId;
    this.token = token;
  }

  init(){
    this.initPuppetSocket();
    this.initPuppetProcess();
  }

  private initPuppetSocket(){
    // Verify code
    this.socket?.on(PuppetEvent.clientSubmitVerifyCode, this.onVerifyCode);
    
    this.socket?.on('disconnect', () => {
      console.log('Socket.IO client disconnected');
      if(this.state == PuppetLoginStatus.login){
        // Logged in, just close the connection
        this.closeConnection();
      } else {
        // Destroy the client
        PuppetService.getInstance(this.serviceId).destroyPuppet(this.clientId);
      }
    });
  }
  // Init the worker process
  private initPuppetProcess(){

    // Handle the message sent by worker process
    this.process.on('message', (message: ProcessMessage)=>{

      // Forward to client if has the collection
      if(message.type == PuppetEvent.puppetDispatchAuthToken){
        // The authorization token (qrCode) generated by wechaty
        // Return to the client
        this.socket?.emit(PuppetEvent.puppetDispatchAuthToken, message.data);
      } else if(message.type == PuppetEvent.puppetRequestVerifyCode){
        // Notify the client to input verification code
        this.socket?.emit(PuppetEvent.puppetRequestVerifyCode);
      } else if(message.type == PuppetEvent.puppetVerifyResult){
        // Report verify result
        console.log('verifyCodeResult:', message.data);
        // Tell the login client
        this.socket?.emit(PuppetEvent.puppetVerifyResult, message.data);
      } else if(message.type == PuppetEvent.puppetLoginStatus){
        // Report verify result
        console.log('login status:', message.data);
        // Tell the login client
        this.socket?.emit(PuppetEvent.puppetLoginStatus, message.data);
        if(message.data == PuppetLoginStatus.login){
          // Verify code passed, disable the timeout, so the puppet will serve for the customer
          PuppetService.getInstance(this.serviceId).disableTimeout(this.clientId);
        } else if(message.data == PuppetLoginStatus.logout){
          if(this.state == PuppetLoginStatus.login){
            // Logout
            PuppetService.getInstance(this.serviceId).destroyPuppet(this.clientId);
          } else {
            // Just status update after connect, wait for later event
          }
        }
        this.state = message.data;
      } else if(message.type == PuppetEvent.puppetError){
        // Tell the login client
        this.socket?.emit(PuppetEvent.puppetError, message.data);
        PuppetService.getInstance(this.serviceId).destroyPuppet(this.clientId);
      }
    });
  }

  // Client submit verification code for login
  private onVerifyCode = (verificationCode: string) => {

    this.process.send({ type: PuppetEvent.clientSubmitVerifyCode, data: verificationCode });
  }

  updateSocket(newSocket: Socket): void {
    this.socket = newSocket;
    // Socket updated, send the login status
    this.socket?.emit(PuppetEvent.puppetLoginStatus, this.state);
  }

  logout() {
    if(this.state == PuppetLoginStatus.login){
      console.log('Request logout');
      this.process.send({ type: PuppetEvent.clientRequestLogout });
    }
  }
  
  closeConnection() {
    if(this.socket){
      this.socket.disconnect();
      this.socket = null;
    }
  }
}


export class PuppetService {

  private static instances: Map<WebSocketServiceType, PuppetService> = new Map();

  processManager = new ProcessManager();
  tokenManager;
  private serviceId;
  private puppets: Map<string, Puppet> = new Map();
  private timeouts: Map<string, NodeJS.Timeout> = new Map();

  static getInstance(serviceId: WebSocketServiceType) : PuppetService {
    let service = PuppetService.instances.get(serviceId);
    if (!service) {
      service = new PuppetService(serviceId);
      PuppetService.instances.set(serviceId, service);
    }
    return service;
  }
  
  private constructor(serviceId: WebSocketServiceType) {
    this.serviceId = serviceId;
    this.tokenManager = new TokenManager(JSON.parse(process.env.PUPPET_TOKENS ?? '[]'));
  }

  createPuppet(serviceId: WebSocketServiceType, clientId: string, socket: Socket) {
    // Check if puppet with clientId already exists
    const existingPuppet = this.puppets.get(clientId);

    if (existingPuppet) {
      // Update the socket of the existing puppet
      existingPuppet.updateSocket(socket);
    } else {
      // Aquire token
      const token = this.tokenManager.requestToken();
      if(token){
        // Start worker process for wechaty puppet
        const puppetWorker = this.processManager.startProcess(
          process.env.NODE_ENV == 'production'?
          './puppet-worker.js' : './puppet-worker.ts', 
          clientId, 
          [serviceId, clientId, token]);

        const puppet = new Puppet(serviceId, clientId, socket, token, puppetWorker);
        // Init the worker
        puppet.init();
        this.puppets.set(clientId, puppet);

        // Terminate the child process in 3 minutes by default
        const timeout = setTimeout(() => {
          this.destroyPuppet(clientId);
        }, 3 * 60 * 1000);
        this.timeouts.set(clientId, timeout);
      } else {
        socket.emit(PuppetEvent.puppetError, 'No available headcount');
        socket.disconnect();
        console.warn('No available headcount');
      }
    }
  }

  destroyPuppet(clientId: string){
    const existingPuppet = this.puppets.get(clientId);
    if (existingPuppet) {
      this.tokenManager.releaseToken(existingPuppet.token);
      existingPuppet.closeConnection();
    }
    this.disableTimeout(clientId);
    this.processManager.terminateProcess(clientId);
    this.puppets.delete(clientId);
  }

  // Disable the timeout for child process
  disableTimeout(clientId: string): void {
    const timeout = this.timeouts.get(clientId);
    if (timeout) {
      clearTimeout(timeout);
      this.timeouts.delete(clientId);
    }
  }

  getPuppets(): Puppet[] {
    // Return the values of puppets as an array
    return Array.from(this.puppets.values());
  }

  getPuppet(clientId: string): Puppet | undefined {
    return this.puppets.get(clientId);
  }

  static handleServiceRequest(socket: Socket): void {

    // Register socket callback for puppy management services
    // Get puppet list
    socket.on(ControllerEvent.listPuppets, (service, callback) => {
      const puppets = PuppetService.getInstance(service).getPuppets();
      callback(puppets.map((v) => {
        return {
          clientId: v.clientId,
          state: v.state,
        };
      }));
      socket.disconnect();
    });

    // Destroy a puppet
    socket.on(ControllerEvent.destroyPuppet, (service, clientId, callback) => {
      const puppet = PuppetService.getInstance(service).getPuppet(clientId);
      if (puppet) {
        if(puppet.state === PuppetLoginStatus.login){
          // Logout will trigger the destroy
          puppet.logout();
        } else {
          PuppetService.getInstance(service).destroyPuppet(clientId);
        }
      } else {
        console.warn(`Puppet of ${service}:${clientId} is not found`);
      }
      callback("ok");
      socket.disconnect();
    });
  }
}